** This gives a glimpse of our development flow

1. Let's learn useState(). Before React 16.8, in any component if we had to use state and setState in a functional component
   then we first had to convert that into a class based component and then use state and setState. Now from React version 16.8
   we can use useState() method inside the function. We are using this now in IngredientForm.js. Note that anything starting 
   with use can be used only inside a functional component and not in class based. Also, in class based if we use state then 
   only a javascript object (and not any other type) can be assigned to the state, whereas anything including the object can 
   be assigned to useState like variables, arrays, objects and so on.
   useState() returns an array of two elements, the first one is the current state (or the updated state) and the second 
   element in the array is function that allows you to update your first element which is the actual state. 
   We get warning if we do update any particular value out of many values in an object like how we do in setState. We'll see 
   why this happens next.

2. The way we use the state is correct (the first element of array is correct) but the way we update the state isn't correct, 
   I mean the second element usage is not correct. There is an important difference between useState second element and the 
   setState.  In setState, whichever part of the object we change will then be merged into existing state where as in useState 
   that doesn't happen. I mean

   setState                                         vs                      useState (update - 2nd element of array)

   state = {                                                                    inputState = useState({ a:'A', b:'B', c:'C'  })
       a:'A',
       b:'B',
       c:'C'
   }

   setState({a:'D'})                                                            inputState[1].a = 'D'

   This will give us new state                                                  This would give us new state
   { a:'D', b:'B', c:'C'  }                                                      {a:'D'}

  * Here the existing state is merged with new state,                     *   Here existing state is not merged with new state,
    old elements are retained.                                                and old elements would be lost.

  * So basically it updates old state                                     *   So basically it replaces old state

  This is what happens in the previous commit and we get the error. First we update the state for the title and that removes the 
  number (amount) property because it replaces the state to have only the title hence we get the warning.

  This is the warning we got in previous commit
  index.js:1406 Warning: A component is changing a controlled input of type number to be uncontrolled. Input elements should not 
  switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncont

  Even though this seems like a bad change there is a reason of flexibility here. So when updating state this way, we need to make
  sure we retain all the properties by just writing the left out properties.

3. But this method of updating the state (using title:inputState[0].title) doesn't guarantee the state update is the latest one. 
   Because react sometimes postpones the state update when lot of animations are going on. So when we use inputState[0] to update 
   the title, we can not be sure we will get the right current state. So this is also not recommended way of doing it. We can 
   instead use function to get access to most updated state and then use that. This is like prevState we used when we accessed 
   state within setState in class based component.

4. inputState[0] is the actual state and inputState[1] is the function used for updating that state. It's confusing to use this 
   kind of representation. Hence we can use the feature of ES6, Array Destructuring. This helps to pull elements out of array
   and assign them to the elements mentioned of left hand side.

   const [inputState,setInputState ] = useState({......})
   Now inputState is the actual state and the setInputState is the function to update the inputState. 

5. All good but did you realise the point mentioned in 2 and 3. Unlike state the useState doesnt merge the non updated elements 
   with updated elements. So in point 3 I told we have to write other properties manually ourselves. Don't you think this is 
   tedious and time consuming. Yes it is. So would it be better if we some how could update only what we want and retain others?
   There is a way! Just use multiple useStates. Yes! that is possible. In this way you can update only the one you need and rest
   will remain the same. So I mean, this time we don't need to have an object but a single variable in the useState and multiple 
   such useStates for different variables.
   So the conclusion is we better need to split our state into multiple useStates using single variables in each unless its very
   necessary that we have some use case to use objects like what we did previously where multiple things change together.

6. The rule with useState or any use** hooks are that they can be used only at the root level and not inside of any loop of 
   function. 

   Not allowed examples:

   if(something){
       useState(); // Not allowed to use this way 
   }

   const submitHandler() {
       useState(); // Not allowed to use this way 
   }

7. Let's now take care of adding the ingredients upon the Add Ingredient button click in IngredientForm. This can be handled in 
   IngredientForm itself but the better place to handle this would be in ingredients because it has access to input and output.

8. Let's now work with removing ingredients.

9. Now it's time to test some react life cycle hooks with functional components. In class based we have componentDidMount, 
   componentWillMount and so on which can't be used in functional component. So, how do we test this. Well we can send some 
   data to backend (we used axios for this in BurgerBuilder, now lets use fetch api given by modern browser, not react). Once 
   we send the data to firebase then we can retreive the data after the component reloads. To retreive the data after the component 
   gets reloaded we used componentDidMount and hence we had to convert the functional component into class based. Now since we use
   react hooks we can implement life cycle hooks differently. 
   So, let's begin with sending the ingredients to backend when clicked on Add Ingredient button using fetch api. There is a small
   difference between fetch and axios which I will mention using comments in the code.

10. Now that we are sending the data to the firebase on click of Add Ingredient button, we will now fetch those ingredients on the 
    app reload. As I said in point 9, we used to do this in componentDidMount in class based. This is done by useEffect hook. 
    This hook runs after the component gets rendered the first time AND for every render cycle (Meaning if something gets modified
    and the component if rerenders again). Watch video. 434. useEffect() and Loading Data.
    You might think we can normally load the ingredients using fetch or axios in the outer level (somewhere after the useState)
    without using it inside useEffect. But the problem is, if we do that then the setInputState (which is setState) changes the state
    and then the  Ingredients component rerenders and then this happens for infinite times creating infinite loop. Hence we do this 
    in useEffect hook. useEffect is enough to replace all the life cycle hooks.

    useEffect (without second arg) by default acts like componentDidUpdate. Which means if there is a state change within useEffect 
    (without second arg) then it rerenders the component and then executes useEffect again there by executes the line which changes 
    the state and so on. This creates an infinite loop as I said. So for our requirement of fetching ingredients, it should be done 
    at once so the useEffect should be run only once. For this we need a second argument with an array of dependencies and if that 
    dependencies change only then the component rerenders and useEffect will run again. Providing empty array as a second argument 
    means that it has no dependencies and it runs only once.

11. What do I mean by dependencies of 2nd argument ? Well take a look here

      useEffect (()={
         console.log("The ingredients are ",userIngredients);
      },[userIngredients])

      Here userIngredients is a dependency that means, we are telling useEffect to rerun only if userIngredients change otherwise it 
      shouldn't run second time.

12. Let's now make the search bar work. If we type Apple in search only Apple should appear if that exists in loadedIngredients. Note
    that we are doing a full search here in this project meaning if we type Apple completely then only the apple appears if it exists.
    Recommended watch video. 436. More on useEffect and 437. what's useCallback() ?
    In the Search component we need to filter the data as per enteredFilter value. Firebase provides the way to do this which we use 
    in useEffect of Search to get the filtered ingredients (filtering by enteredFilter). Adjust rules in the firebase for this. 