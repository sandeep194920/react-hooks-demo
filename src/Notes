** This gives a glimpse of our development flow

1. Let's learn useState(). Before React 16.8, in any component if we had to use state and setState in a functional component
   then we first had to convert that into a class based component and then use state and setState. Now from React version 16.8
   we can use useState() method inside the function. We are using this now in IngredientForm.js. Note that anything starting 
   with use can be used only inside a functional component and not in class based. Also, in class based if we use state then 
   only a javascript object (and not any other type) can be assigned to the state, whereas anything including the object can 
   be assigned to useState like variables, arrays, objects and so on.
   useState() returns an array of two elements, the first one is the current state (or the updated state) and the second 
   element in the array is function that allows you to update your first element which is the actual state. 
   We get warning if we do update any particular value out of many values in an object like how we do in setState. We'll see 
   why this happens next.

2. The way we use the state is correct (the first element of array is correct) but the way we update the state isn't correct, 
   I mean the second element usage is not correct. There is an important difference between useState second element and the 
   setState.  In setState, whichever part of the object we change will then be merged into existing state where as in useState 
   that doesn't happen. I mean

   setState                                         vs                      useState (update - 2nd element of array)

   state = {                                                                    inputState = useState({ a:'A', b:'B', c:'C'  })
       a:'A',
       b:'B',
       c:'C'
   }

   setState({a:'D'})                                                            inputState[1].a = 'D'

   This will give us new state                                                  This would give us new state
   { a:'D', b:'B', c:'C'  }                                                      {a:'D'}

  * Here the existing state is merged with new state,                     *   Here existing state is not merged with new state,
    old elements are retained.                                                and old elements would be lost.

  * So basically it updates old state                                     *   So basically it replaces old state

  This is what happens in the previous commit and we get the error. First we update the state for the title and that removes the 
  number (amount) property because it replaces the state to have only the title hence we get the warning.

  This is the warning we got in previous commit
  index.js:1406 Warning: A component is changing a controlled input of type number to be uncontrolled. Input elements should not 
  switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncont

  Even though this seems like a bad change there is a reason of flexibility here. So when updating state this way, we need to make
  sure we retain all the properties by just writing the left out properties.

3. But this method of updating the state (using title:inputState[0].title) doesn't guarantee the state update is the latest one. 
   Because react sometimes postpones the state update when lot of animations are going on. So when we use inputState[0] to update 
   the title, we can not be sure we will get the right current state. So this is also not recommended way of doing it. We can 
   instead use function to get access to most updated state and then use that. This is like prevState we used when we accessed 
   state within setState in class based component.

4. inputState[0] is the actual state and inputState[1] is the function used for updating that state. It's confusing to use this 
   kind of representation. Hence we can use the feature of ES6, Array Destructuring. This helps to pull elements out of array
   and assign them to the elements mentioned of left hand side.

   const [inputState,setInputState ] = useState({......})
   Now inputState is the actual state and the setInputState is the function to update the inputState. 

5. All good but did you realise the point mentioned in 2 and 3. Unlike state the useState doesnt merge the non updated elements 
   with updated elements. So in point 3 I told we have to write other properties manually ourselves. Don't you think this is 
   tedious and time consuming. Yes it is. So would it be better if we some how could update only what we want and retain others?
   There is a way! Just use multiple useStates. Yes! that is possible. In this way you can update only the one you need and rest
   will remain the same. So I mean, this time we don't need to have an object but a single variable in the useState and multiple 
   such useStates for different variables.
   So the conclusion is we better need to split our state into multiple useStates using single variables in each unless its very
   necessary that we have some use case to use objects like what we did previously where multiple things change together.

6. The rule with useState or any use** hooks are that they can be used only at the root level and not inside of any loop of 
   function. 

   Not allowed examples:

   if(something){
       useState(); // Not allowed to use this way 
   }

   const submitHandler() {
       useState(); // Not allowed to use this way 
   }

7. Let's now take care of adding the ingredients upon the Add Ingredient button click in IngredientForm. This can be handled in 
   IngredientForm itself but the better place to handle this would be in ingredients because it has access to input and output.

8. Let's now work with removing ingredients.